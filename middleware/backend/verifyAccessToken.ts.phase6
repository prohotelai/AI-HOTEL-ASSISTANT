/**
 * Verify Access Token Middleware
 * Validates JWT access tokens and extracts session information
 */

import { NextRequest, NextResponse } from 'next/server'
import { validateSession } from '@/lib/services/session/sessionService'

export interface AuthenticatedRequest extends NextRequest {
  userId?: string
  sessionId?: string
  hotelId?: string
  role?: string
  suspiciousFlags?: string[]
}

/**
 * Verify access token from Authorization header or cookie
 * @param request - Next.js request object
 * @returns Updated request with session info, or error response
 */
export async function verifyAccessToken(request: NextRequest): Promise<{
  success: boolean
  userId?: string
  sessionId?: string
  hotelId?: string
  role?: string
  suspiciousFlags?: string[]
  error?: string
}> {
  try {
    // Get token from Authorization header or cookie
    const authHeader = request.headers.get('authorization')
    const cookieToken = request.cookies.get('accessToken')?.value
    
    const token = authHeader?.replace('Bearer ', '') || cookieToken
    
    if (!token) {
      return {
        success: false,
        error: 'No access token provided'
      }
    }
    
    // Get user agent and IP from request
    const userAgent = request.headers.get('user-agent') || 'unknown'
    const ipAddress = getIPFromRequest(request)
    
    // Validate session using the token
    const validationResult = await validateSession(token, {
      userAgent,
      ipAddress
    })
    
    if (!validationResult.valid) {
      return {
        success: false,
        error: validationResult.error
      }
    }
    
    return {
      success: true,
      userId: validationResult.userId,
      sessionId: validationResult.sessionId,
      hotelId: validationResult.hotelId,
      role: validationResult.role,
      suspiciousFlags: validationResult.suspiciousFlags
    }
  } catch (error) {
    console.error('Token verification error:', error)
    return {
      success: false,
      error: 'Token verification failed'
    }
  }
}

/**
 * Extract IP address from request
 * Handles X-Forwarded-For, X-Real-IP, and direct connection
 * @param request - Request object
 * @returns IP address string
 */
export function getIPFromRequest(request: NextRequest): string {
  // Check for X-Forwarded-For header (proxy, load balancer)
  const xForwardedFor = request.headers.get('x-forwarded-for')
  if (xForwardedFor) {
    return xForwardedFor.split(',')[0].trim()
  }
  
  // Check for X-Real-IP header
  const xRealIp = request.headers.get('x-real-ip')
  if (xRealIp) {
    return xRealIp
  }
  
  // Direct connection
  const ip = request.ip || request.socket?.remoteAddress
  return ip || '0.0.0.0'
}

/**
 * Middleware to enforce authenticated requests
 * Use in Route Handlers to protect endpoints
 * @param handler - Route handler function
 * @returns Wrapped handler with authentication
 */
export function withAuth(
  handler: (
    req: NextRequest,
    context: any,
    auth: NonNullable<Awaited<ReturnType<typeof verifyAccessToken>>>
  ) => Promise<NextResponse>
) {
  return async (req: NextRequest, context: any) => {
    const auth = await verifyAccessToken(req)
    
    if (!auth.success) {
      return NextResponse.json(
        { error: auth.error || 'Unauthorized' },
        { status: 401 }
      )
    }
    
    return handler(req, context, auth as NonNullable<typeof auth>)
  }
}

/**
 * Middleware to enforce specific roles
 * @param requiredRoles - Array of required roles
 * @returns Middleware function
 */
export function withRole(...requiredRoles: string[]) {
  return (handler: Function) => {
    return async (req: NextRequest, context: any) => {
      const auth = await verifyAccessToken(req)
      
      if (!auth.success) {
        return NextResponse.json(
          { error: 'Unauthorized' },
          { status: 401 }
        )
      }
      
      if (!auth.role || !requiredRoles.includes(auth.role)) {
        return NextResponse.json(
          { error: 'Forbidden - insufficient permissions' },
          { status: 403 }
        )
      }
      
      return handler(req, context, auth)
    }
  }
}

/**
 * Middleware to enforce hotel boundary
 * Verifies user/session belongs to the hotel in the request
 * @param handler - Route handler
 * @returns Wrapped handler with hotel verification
 */
export function withHotelBoundary(
  handler: (
    req: NextRequest,
    context: any,
    auth: NonNullable<Awaited<ReturnType<typeof verifyAccessToken>>>
  ) => Promise<NextResponse>
) {
  return async (req: NextRequest, context: any) => {
    const auth = await verifyAccessToken(req)
    
    if (!auth.success) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      )
    }
    
    // Extract hotelId from URL params or query
    const hotelIdParam = context.params?.hotelId || 
                         new URL(req.url).searchParams.get('hotelId')
    
    if (!hotelIdParam) {
      return NextResponse.json(
        { error: 'Hotel ID required' },
        { status: 400 }
      )
    }
    
    // Verify session's hotelId matches request hotelId
    if (auth.hotelId !== hotelIdParam) {
      return NextResponse.json(
        { error: 'Access denied - wrong hotel' },
        { status: 403 }
      )
    }
    
    return handler(req, context, auth as NonNullable<typeof auth>)
  }
}
