/**
 * Invoice Service - Invoice generation and management
 */

import { prisma } from '@/lib/prisma'

export interface InvoiceData {
  folioId: string
  dueDate?: Date
  taxRate?: number
  discountAmount?: number
  notes?: string
}

export const invoiceService = {
  // Generate invoice from folio
  async generateInvoice(data: InvoiceData) {
    const { folioId, dueDate, taxRate = 0, discountAmount = 0, notes } = data

    // Get folio with items
    const folio = await prisma.folio.findUnique({
      where: { id: folioId },
      include: {
        items: true,
        booking: {
          include: {
            guest: true,
            roomType: true,
            room: true
          }
        },
        hotel: true
      }
    })

    if (!folio) {
      throw new Error('Folio not found')
    }

    if (folio.status === 'CLOSED') {
      throw new Error('Cannot generate invoice for closed folio')
    }

    // Calculate totals
    const subtotal = folio.items.reduce((sum, item) => sum + item.amount, 0)
    const taxAmount = (subtotal - discountAmount) * (taxRate / 100)
    const totalAmount = subtotal - discountAmount + taxAmount

    // Create invoice
    const invoice = await prisma.invoice.create({
      data: {
        folioId,
        hotelId: folio.hotelId,
        invoiceNumber: await this.generateInvoiceNumber(folio.hotelId),
        issueDate: new Date(),
        dueDate: dueDate || new Date(),
        subtotal,
        taxAmount,
        discountAmount,
        totalAmount,
        status: 'PENDING',
        notes
      },
      include: {
        folio: {
          include: {
            items: true,
            booking: {
              include: {
                guest: true,
                roomType: true,
                room: true
              }
            }
          }
        }
      }
    })

    return invoice
  },

  // Generate unique invoice number
  async generateInvoiceNumber(hotelId: string): Promise<string> {
    const year = new Date().getFullYear()
    const month = String(new Date().getMonth() + 1).padStart(2, '0')
    
    const lastInvoice = await prisma.invoice.findFirst({
      where: { hotelId },
      orderBy: { invoiceNumber: 'desc' }
    })

    let sequence = 1
    if (lastInvoice) {
      const lastSequence = parseInt(lastInvoice.invoiceNumber.split('-').pop() || '0')
      sequence = lastSequence + 1
    }

    return `INV-${year}${month}-${String(sequence).padStart(5, '0')}`
  },

  // Mark invoice as paid
  async markAsPaid(invoiceId: string, paymentMethod: string, paymentReference?: string) {
    const invoice = await prisma.invoice.update({
      where: { id: invoiceId },
      data: {
        status: 'PAID',
        paidDate: new Date()
      }
    })

    // Create payment record
    await prisma.paymentRecord.create({
      data: {
        folioId: invoice.folioId,
        hotelId: invoice.hotelId,
        amount: invoice.totalAmount,
        paymentMethod: paymentMethod as any,
        paymentReference,
        paidAt: new Date()
      }
    })

    // Update folio balance
    await prisma.folio.update({
      where: { id: invoice.folioId },
      data: {
        paidAmount: {
          increment: invoice.totalAmount
        }
      }
    })

    return invoice
  },

  // Cancel invoice
  async cancelInvoice(invoiceId: string, reason?: string) {
    return prisma.invoice.update({
      where: { id: invoiceId },
      data: {
        status: 'CANCELLED',
        notes: reason || 'Invoice cancelled'
      }
    })
  },

  // Get invoice by ID
  async getInvoiceById(invoiceId: string) {
    return prisma.invoice.findUnique({
      where: { id: invoiceId },
      include: {
        folio: {
          include: {
            items: true,
            booking: {
              include: {
                guest: true,
                roomType: true,
                room: true
              }
            }
          }
        },
        hotel: true
      }
    })
  },

  // Get invoices for hotel
  async getHotelInvoices(
    hotelId: string,
    filters?: {
      status?: string
      startDate?: Date
      endDate?: Date
      limit?: number
      offset?: number
    }
  ) {
    const where: any = { hotelId }

    if (filters?.status) {
      where.status = filters.status
    }

    if (filters?.startDate || filters?.endDate) {
      where.issueDate = {}
      if (filters.startDate) where.issueDate.gte = filters.startDate
      if (filters.endDate) where.issueDate.lte = filters.endDate
    }

    const [invoices, total] = await Promise.all([
      prisma.invoice.findMany({
        where,
        include: {
          folio: {
            include: {
              booking: {
                include: {
                  guest: true
                }
              }
            }
          }
        },
        orderBy: { issueDate: 'desc' },
        take: filters?.limit || 50,
        skip: filters?.offset || 0
      }),
      prisma.invoice.count({ where })
    ])

    return { invoices, total }
  },

  // Generate invoice PDF (placeholder)
  async generateInvoicePDF(invoiceId: string) {
    const invoice = await this.getInvoiceById(invoiceId)
    
    if (!invoice) {
      throw new Error('Invoice not found')
    }

    // TODO: Implement PDF generation using a library like pdfkit or puppeteer
    // For now, return invoice data for external PDF generation
    
    return {
      invoice,
      pdfUrl: `/api/invoices/${invoiceId}/pdf`, // Placeholder
      pdfData: null // TODO: Generate actual PDF buffer
    }
  },

  // Send invoice via email (placeholder)
  async sendInvoiceEmail(invoiceId: string, recipientEmail: string) {
    const invoice = await this.getInvoiceById(invoiceId)
    
    if (!invoice) {
      throw new Error('Invoice not found')
    }

    // TODO: Implement email sending via email service
    // const pdfData = await this.generateInvoicePDF(invoiceId)
    
    console.log(`Sending invoice ${invoice.invoiceNumber} to ${recipientEmail}`)
    
    return {
      success: true,
      message: 'Invoice email sent successfully'
    }
  },

  // Get invoice statistics
  async getInvoiceStats(hotelId: string, startDate: Date, endDate: Date) {
    const invoices = await prisma.invoice.findMany({
      where: {
        hotelId,
        issueDate: {
          gte: startDate,
          lte: endDate
        }
      }
    })

    const totalInvoices = invoices.length
    const totalAmount = invoices.reduce((sum, inv) => sum + inv.totalAmount, 0)
    const paidAmount = invoices
      .filter(inv => inv.status === 'PAID')
      .reduce((sum, inv) => sum + inv.totalAmount, 0)
    const pendingAmount = invoices
      .filter(inv => inv.status === 'PENDING')
      .reduce((sum, inv) => sum + inv.totalAmount, 0)
    const overdueAmount = invoices
      .filter(inv => inv.status === 'OVERDUE')
      .reduce((sum, inv) => sum + inv.totalAmount, 0)

    return {
      totalInvoices,
      totalAmount: Number(totalAmount.toFixed(2)),
      paidAmount: Number(paidAmount.toFixed(2)),
      pendingAmount: Number(pendingAmount.toFixed(2)),
      overdueAmount: Number(overdueAmount.toFixed(2)),
      paidCount: invoices.filter(inv => inv.status === 'PAID').length,
      pendingCount: invoices.filter(inv => inv.status === 'PENDING').length,
      overdueCount: invoices.filter(inv => inv.status === 'OVERDUE').length
    }
  }
}
